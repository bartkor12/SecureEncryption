/*
 * Vencord, a Discord client mod
 * Copyright (c) 2025 Vendicated and contributors
 * SPDX-License-Identifier: GPL-3.0-or-later
 */

var isLE = /* @__PURE__ */ (() => new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68)();

function isBytes(a) {
    return a instanceof Uint8Array || ArrayBuffer.isView(a) && a.constructor.name === "Uint8Array";
}

function abytes(value, length?, title = "") {
    const bytes = isBytes(value);
    const len = value?.length;
    const needsLen = length !== void 0;
    if (!bytes || needsLen && len !== length) {
        const prefix = title && `"${title}" `;
        const ofLen = needsLen ? ` of length ${length}` : "";
        const got = bytes ? `length=${len}` : `type=${typeof value}`;
        throw new Error(prefix + "expected Uint8Array" + ofLen + ", got " + got);
    }
    return value;
}

var wrapCipher = /* @__NO_SIDE_EFFECTS__ */ (params, constructor) => {
    function wrappedCipher(key, ...args) {
        abytes(key, void 0, "key");
        if (!isLE)
            throw new Error("Non little-endian hardware is not yet supported");
        if (params.nonceLength !== void 0) {
            const nonce = args[0];
            abytes(nonce, params.varSizeNonce ? void 0 : params.nonceLength, "nonce");
        }
        const tagl = params.tagLength;
        if (tagl && args[1] !== void 0)
            abytes(args[1], void 0, "AAD");
        const cipher = constructor(key, ...args);
        const checkOutput = (fnLength, output) => {
            if (output !== void 0) {
                if (fnLength !== 2)
                    throw new Error("cipher output not supported");
                abytes(output, void 0, "output");
            }
        };
        let called = false;
        const wrCipher = {
            encrypt(data, output?) {
                if (called)
                    throw new Error("cannot encrypt() twice with same key + nonce");
                called = true;
                abytes(data);
                checkOutput(cipher.encrypt.length, output);
                return cipher.encrypt(data, output);
            },
            decrypt(data, output?) {
                abytes(data);
                if (tagl && data.length < tagl)
                    throw new Error('"ciphertext" expected length bigger than tagLength=' + tagl);
                checkOutput(cipher.decrypt.length, output);
                return cipher.decrypt(data, output);
            }
        };
        return wrCipher;
    }
    Object.assign(wrappedCipher, params);
    return wrappedCipher;
};

function isAligned32(bytes) {
    return bytes.byteOffset % 4 === 0;
}

function getOutput(expectedLength, out, onlyAligned = true) {
    if (out === void 0)
        return new Uint8Array(expectedLength);
    if (out.length !== expectedLength)
        throw new Error('"output" expected Uint8Array of length ' + expectedLength + ", got: " + out.length);
    if (onlyAligned && !isAligned32(out))
        throw new Error("invalid output, must be aligned");
    return out;
}

function wrapConstructorWithKey2(hashCons) {
    const hashC = (msg, key) => hashCons(key).update(msg).digest();
    const tmp = hashCons(new Uint8Array(32));
    hashC.outputLen = tmp.outputLen;
    hashC.blockLen = tmp.blockLen;
    hashC.create = key => hashCons(key);
    return hashC;
}

function copyBytes(bytes): Uint8Array {
    return Uint8Array.from(bytes);
}

function clean(...arrays) {
    for (let i = 0; i < arrays.length; i++) {
        arrays[i].fill(0);
    }
}

function aexists(instance, checkFinished = true) {
    if (instance.destroyed)
        throw new Error("Hash instance has been destroyed");
    if (checkFinished && instance.finished)
        throw new Error("Hash#digest() has already been called");
}

function aoutput(out, instance) {
    abytes(out, void 0, "output");
    const min = instance.outputLen;
    if (out.length < min) {
        throw new Error("digestInto() expects output buffer of length at least " + min);
    }
}

function u8to16(a, i) {
    return a[i++] & 255 | (a[i++] & 255) << 8;
}

var Poly1305 = class {
    blockLen = 16;
    outputLen = 16;
    buffer = new Uint8Array(16);
    r = new Uint16Array(10);
    // Allocating 1 array with .subarray() here is slower than 3
    h = new Uint16Array(10);
    pad = new Uint16Array(8);
    pos = 0;
    finished = false;
    // Can be speed-up using BigUint64Array, at the cost of complexity
    constructor(key) {
        key = copyBytes(abytes(key, 32, "key"));
        const t0 = u8to16(key, 0);
        const t1 = u8to16(key, 2);
        const t2 = u8to16(key, 4);
        const t3 = u8to16(key, 6);
        const t4 = u8to16(key, 8);
        const t5 = u8to16(key, 10);
        const t6 = u8to16(key, 12);
        const t7 = u8to16(key, 14);
        this.r[0] = t0 & 8191;
        this.r[1] = (t0 >>> 13 | t1 << 3) & 8191;
        this.r[2] = (t1 >>> 10 | t2 << 6) & 7939;
        this.r[3] = (t2 >>> 7 | t3 << 9) & 8191;
        this.r[4] = (t3 >>> 4 | t4 << 12) & 255;
        this.r[5] = t4 >>> 1 & 8190;
        this.r[6] = (t4 >>> 14 | t5 << 2) & 8191;
        this.r[7] = (t5 >>> 11 | t6 << 5) & 8065;
        this.r[8] = (t6 >>> 8 | t7 << 8) & 8191;
        this.r[9] = t7 >>> 5 & 127;
        for (let i = 0; i < 8; i++)
            this.pad[i] = u8to16(key, 16 + 2 * i);
    }
    process(data, offset, isLast = false) {
        const hibit = isLast ? 0 : 1 << 11;
        const { h, r } = this;
        const r0 = r[0];
        const r1 = r[1];
        const r2 = r[2];
        const r3 = r[3];
        const r4 = r[4];
        const r5 = r[5];
        const r6 = r[6];
        const r7 = r[7];
        const r8 = r[8];
        const r9 = r[9];
        const t0 = u8to16(data, offset + 0);
        const t1 = u8to16(data, offset + 2);
        const t2 = u8to16(data, offset + 4);
        const t3 = u8to16(data, offset + 6);
        const t4 = u8to16(data, offset + 8);
        const t5 = u8to16(data, offset + 10);
        const t6 = u8to16(data, offset + 12);
        const t7 = u8to16(data, offset + 14);
        const h0 = h[0] + (t0 & 8191);
        const h1 = h[1] + ((t0 >>> 13 | t1 << 3) & 8191);
        const h2 = h[2] + ((t1 >>> 10 | t2 << 6) & 8191);
        const h3 = h[3] + ((t2 >>> 7 | t3 << 9) & 8191);
        const h4 = h[4] + ((t3 >>> 4 | t4 << 12) & 8191);
        const h5 = h[5] + (t4 >>> 1 & 8191);
        const h6 = h[6] + ((t4 >>> 14 | t5 << 2) & 8191);
        const h7 = h[7] + ((t5 >>> 11 | t6 << 5) & 8191);
        const h8 = h[8] + ((t6 >>> 8 | t7 << 8) & 8191);
        const h9 = h[9] + (t7 >>> 5 | hibit);
        let c = 0;
        let d0 = c + h0 * r0 + h1 * (5 * r9) + h2 * (5 * r8) + h3 * (5 * r7) + h4 * (5 * r6);
        c = d0 >>> 13;
        d0 &= 8191;
        d0 += h5 * (5 * r5) + h6 * (5 * r4) + h7 * (5 * r3) + h8 * (5 * r2) + h9 * (5 * r1);
        c += d0 >>> 13;
        d0 &= 8191;
        let d1 = c + h0 * r1 + h1 * r0 + h2 * (5 * r9) + h3 * (5 * r8) + h4 * (5 * r7);
        c = d1 >>> 13;
        d1 &= 8191;
        d1 += h5 * (5 * r6) + h6 * (5 * r5) + h7 * (5 * r4) + h8 * (5 * r3) + h9 * (5 * r2);
        c += d1 >>> 13;
        d1 &= 8191;
        let d2 = c + h0 * r2 + h1 * r1 + h2 * r0 + h3 * (5 * r9) + h4 * (5 * r8);
        c = d2 >>> 13;
        d2 &= 8191;
        d2 += h5 * (5 * r7) + h6 * (5 * r6) + h7 * (5 * r5) + h8 * (5 * r4) + h9 * (5 * r3);
        c += d2 >>> 13;
        d2 &= 8191;
        let d3 = c + h0 * r3 + h1 * r2 + h2 * r1 + h3 * r0 + h4 * (5 * r9);
        c = d3 >>> 13;
        d3 &= 8191;
        d3 += h5 * (5 * r8) + h6 * (5 * r7) + h7 * (5 * r6) + h8 * (5 * r5) + h9 * (5 * r4);
        c += d3 >>> 13;
        d3 &= 8191;
        let d4 = c + h0 * r4 + h1 * r3 + h2 * r2 + h3 * r1 + h4 * r0;
        c = d4 >>> 13;
        d4 &= 8191;
        d4 += h5 * (5 * r9) + h6 * (5 * r8) + h7 * (5 * r7) + h8 * (5 * r6) + h9 * (5 * r5);
        c += d4 >>> 13;
        d4 &= 8191;
        let d5 = c + h0 * r5 + h1 * r4 + h2 * r3 + h3 * r2 + h4 * r1;
        c = d5 >>> 13;
        d5 &= 8191;
        d5 += h5 * r0 + h6 * (5 * r9) + h7 * (5 * r8) + h8 * (5 * r7) + h9 * (5 * r6);
        c += d5 >>> 13;
        d5 &= 8191;
        let d6 = c + h0 * r6 + h1 * r5 + h2 * r4 + h3 * r3 + h4 * r2;
        c = d6 >>> 13;
        d6 &= 8191;
        d6 += h5 * r1 + h6 * r0 + h7 * (5 * r9) + h8 * (5 * r8) + h9 * (5 * r7);
        c += d6 >>> 13;
        d6 &= 8191;
        let d7 = c + h0 * r7 + h1 * r6 + h2 * r5 + h3 * r4 + h4 * r3;
        c = d7 >>> 13;
        d7 &= 8191;
        d7 += h5 * r2 + h6 * r1 + h7 * r0 + h8 * (5 * r9) + h9 * (5 * r8);
        c += d7 >>> 13;
        d7 &= 8191;
        let d8 = c + h0 * r8 + h1 * r7 + h2 * r6 + h3 * r5 + h4 * r4;
        c = d8 >>> 13;
        d8 &= 8191;
        d8 += h5 * r3 + h6 * r2 + h7 * r1 + h8 * r0 + h9 * (5 * r9);
        c += d8 >>> 13;
        d8 &= 8191;
        let d9 = c + h0 * r9 + h1 * r8 + h2 * r7 + h3 * r6 + h4 * r5;
        c = d9 >>> 13;
        d9 &= 8191;
        d9 += h5 * r4 + h6 * r3 + h7 * r2 + h8 * r1 + h9 * r0;
        c += d9 >>> 13;
        d9 &= 8191;
        c = (c << 2) + c | 0;
        c = c + d0 | 0;
        d0 = c & 8191;
        c >>>= 13;
        d1 += c;
        h[0] = d0;
        h[1] = d1;
        h[2] = d2;
        h[3] = d3;
        h[4] = d4;
        h[5] = d5;
        h[6] = d6;
        h[7] = d7;
        h[8] = d8;
        h[9] = d9;
    }
    finalize() {
        const { h, pad } = this;
        const g = new Uint16Array(10);
        let c = h[1] >>> 13;
        h[1] &= 8191;
        for (let i = 2; i < 10; i++) {
            h[i] += c;
            c = h[i] >>> 13;
            h[i] &= 8191;
        }
        h[0] += c * 5;
        c = h[0] >>> 13;
        h[0] &= 8191;
        h[1] += c;
        c = h[1] >>> 13;
        h[1] &= 8191;
        h[2] += c;
        g[0] = h[0] + 5;
        c = g[0] >>> 13;
        g[0] &= 8191;
        for (let i = 1; i < 10; i++) {
            g[i] = h[i] + c;
            c = g[i] >>> 13;
            g[i] &= 8191;
        }
        g[9] -= 1 << 13;
        let mask = (c ^ 1) - 1;
        for (let i = 0; i < 10; i++)
            g[i] &= mask;
        mask = ~mask;
        for (let i = 0; i < 10; i++)
            h[i] = h[i] & mask | g[i];
        h[0] = (h[0] | h[1] << 13) & 65535;
        h[1] = (h[1] >>> 3 | h[2] << 10) & 65535;
        h[2] = (h[2] >>> 6 | h[3] << 7) & 65535;
        h[3] = (h[3] >>> 9 | h[4] << 4) & 65535;
        h[4] = (h[4] >>> 12 | h[5] << 1 | h[6] << 14) & 65535;
        h[5] = (h[6] >>> 2 | h[7] << 11) & 65535;
        h[6] = (h[7] >>> 5 | h[8] << 8) & 65535;
        h[7] = (h[8] >>> 8 | h[9] << 5) & 65535;
        let f = h[0] + pad[0];
        h[0] = f & 65535;
        for (let i = 1; i < 8; i++) {
            f = (h[i] + pad[i] | 0) + (f >>> 16) | 0;
            h[i] = f & 65535;
        }
        clean(g);
    }
    update(data) {
        aexists(this);
        abytes(data);
        data = copyBytes(data);
        const { buffer, blockLen } = this;
        const len = data.length;
        for (let pos = 0; pos < len;) {
            const take = Math.min(blockLen - this.pos, len - pos);
            if (take === blockLen) {
                for (; blockLen <= len - pos; pos += blockLen)
                    this.process(data, pos);
                continue;
            }
            buffer.set(data.subarray(pos, pos + take), this.pos);
            this.pos += take;
            pos += take;
            if (this.pos === blockLen) {
                this.process(buffer, 0, false);
                this.pos = 0;
            }
        }
        return this;
    }
    destroy() {
        clean(this.h, this.r, this.buffer, this.pad);
    }
    digestInto(out) {
        aexists(this);
        aoutput(out, this);
        this.finished = true;
        const { buffer, h } = this;
        let { pos } = this;
        if (pos) {
            buffer[pos++] = 1;
            for (; pos < 16; pos++)
                buffer[pos] = 0;
            this.process(buffer, 0, true);
        }
        this.finalize();
        let opos = 0;
        for (let i = 0; i < 8; i++) {
            out[opos++] = h[i] >>> 0;
            out[opos++] = h[i] >>> 8;
        }
        return out;
    }
    digest() {
        const { buffer, outputLen } = this;
        this.digestInto(buffer);
        const res = buffer.slice(0, outputLen);
        this.destroy();
        return res;
    }
};

function createView(arr) {
    return new DataView(arr.buffer, arr.byteOffset, arr.byteLength);
}

function abool(b) {
    if (typeof b !== "boolean")
        throw new Error(`boolean expected, not ${b}`);
}

function u64Lengths(dataLength, aadLength, isLE2) {
    abool(isLE2);
    const num = new Uint8Array(16);
    const view = createView(num);
    view.setBigUint64(0, BigInt(aadLength), isLE2);
    view.setBigUint64(8, BigInt(dataLength), isLE2);
    return num;
}

var ZEROS162 = /* @__PURE__ */ new Uint8Array(16);
var updatePadded = (h, msg) => {
    h.update(msg);
    const leftover = msg.length % 16;
    if (leftover)
        h.update(ZEROS162.subarray(leftover));
};

var poly1305 = /* @__PURE__ */ (() => wrapConstructorWithKey2(key => new Poly1305(key)))();

var ZEROS322 = /* @__PURE__ */ new Uint8Array(32);
function computeTag2(fn, key, nonce, ciphertext, AAD) {
    if (AAD !== void 0)
        abytes(AAD, void 0, "AAD");
    const authKey = fn(key, nonce, ZEROS322);
    const lengths = u64Lengths(ciphertext.length, AAD ? AAD.length : 0, true);
    const h = poly1305.create(authKey);
    if (AAD)
        updatePadded(h, AAD);
    updatePadded(h, ciphertext);
    h.update(lengths);
    const res = h.digest();
    clean(authKey, lengths);
    return res;
}

function equalBytes(a, b) {
    if (a.length !== b.length)
        return false;
    let diff = 0;
    for (let i = 0; i < a.length; i++)
        diff |= a[i] ^ b[i];
    return diff === 0;
}

var _poly1305_aead = xorStream => (key, nonce, AAD) => {
    const tagLength = 16;
    return {
        encrypt(plaintext, output) {
            const plength = plaintext.length;
            output = getOutput(plength + tagLength, output, false);
            output.set(plaintext);
            const oPlain = output.subarray(0, -tagLength);
            xorStream(key, nonce, oPlain, oPlain, 1);
            const tag = computeTag2(xorStream, key, nonce, oPlain, AAD);
            output.set(tag, plength);
            clean(tag);
            return output;
        },
        decrypt(ciphertext, output) {
            output = getOutput(ciphertext.length - tagLength, output, false);
            const data = ciphertext.subarray(0, -tagLength);
            const passedTag = ciphertext.subarray(-tagLength);
            const tag = computeTag2(xorStream, key, nonce, data, AAD);
            if (!equalBytes(passedTag, tag))
                throw new Error("invalid tag");
            output.set(ciphertext.subarray(0, -tagLength));
            xorStream(key, nonce, output, output, 1);
            clean(tag);
            return output;
        }
    };
};

function anumber(n) {
    if (!Number.isSafeInteger(n) || n < 0)
        throw new Error("positive integer expected, got " + n);
}

function checkOpts(defaults, opts) {
    if (opts == null || typeof opts !== "object")
        throw new Error("options must be defined");
    const merged = Object.assign(defaults, opts);
    return merged;
}
var MAX_COUNTER = 2 ** 32 - 1;

function isAligned322(b) {
    return b.byteOffset % 4 === 0;
}

function u32(arr) {
    return new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));
}

var encodeStr = str => Uint8Array.from(str.split(""), c => (c as any).charCodeAt(0));
var sigma16 = encodeStr("expand 16-byte k");
var sigma32 = encodeStr("expand 32-byte k");
var sigma16_32 = u32(sigma16);
var sigma32_32 = u32(sigma32);
var BLOCK_LEN = 64;
var BLOCK_LEN32 = 16;
var MAX_COUNTER = 2 ** 32 - 1;
var U32_EMPTY = Uint32Array.of();

function runCipher(core, sigma, key, nonce, data, output, counter, rounds) {
    const len = data.length;
    const block = new Uint8Array(BLOCK_LEN);
    const b32 = u32(block);
    const isAligned = isAligned322(data) && isAligned322(output);
    const d32 = isAligned ? u32(data) : U32_EMPTY;
    const o32 = isAligned ? u32(output) : U32_EMPTY;
    for (let pos = 0; pos < len; counter++) {
        core(sigma, key, nonce, b32, counter, rounds);
        if (counter >= MAX_COUNTER)
            throw new Error("arx: counter overflow");
        const take = Math.min(BLOCK_LEN, len - pos);
        if (isAligned && take === BLOCK_LEN) {
            const pos32 = pos / 4;
            if (pos % 4 !== 0)
                throw new Error("arx: invalid block position");
            for (let j = 0, posj; j < BLOCK_LEN32; j++) {
                posj = pos32 + j;
                o32[posj] = d32[posj] ^ b32[j];
            }
            pos += BLOCK_LEN;
            continue;
        }
        for (let j = 0, posj; j < take; j++) {
            posj = pos + j;
            output[posj] = data[posj] ^ block[j];
        }
        pos += take;
    }
}

function createCipher(core, opts) {
    const { allowShortKeys, extendNonceFn, counterLength, counterRight, rounds } = checkOpts({ allowShortKeys: false, counterLength: 8, counterRight: false, rounds: 20 }, opts);
    if (typeof core !== "function")
        throw new Error("core must be a function");
    anumber(counterLength);
    anumber(rounds);
    abool(counterRight);
    abool(allowShortKeys);
    return (key, nonce, data, output, counter = 0) => {
        abytes(key, void 0, "key");
        abytes(nonce, void 0, "nonce");
        abytes(data, void 0, "data");
        const len = data.length;
        if (output === void 0)
            output = new Uint8Array(len);
        abytes(output, void 0, "output");
        anumber(counter);
        if (counter < 0 || counter >= MAX_COUNTER)
            throw new Error("arx: counter overflow");
        if (output.length < len)
            throw new Error(`arx: output (${output.length}) is shorter than data (${len})`);
        const toClean: Uint8Array[] = [];
        const l = key.length;
        let k;
        let sigma;
        if (l === 32) {
            toClean.push(k = copyBytes(key));
            sigma = sigma32_32;
        } else if (l === 16 && allowShortKeys) {
            k = new Uint8Array(32);
            k.set(key);
            k.set(key, 16);
            sigma = sigma16_32;
            toClean.push(k);
        } else {
            abytes(key, 32, "arx key");
            throw new Error("invalid key size");
        }
        if (!isAligned322(nonce))
            toClean.push(nonce = copyBytes(nonce));
        const k32 = u32(k);
        if (extendNonceFn) {
            if (nonce.length !== 24)
                throw new Error("arx: extended nonce must be 24 bytes");
            extendNonceFn(sigma, k32, u32(nonce.subarray(0, 16)), k32);
            nonce = nonce.subarray(16);
        }
        const nonceNcLen = 16 - counterLength;
        if (nonceNcLen !== nonce.length)
            throw new Error(`arx: nonce must be ${nonceNcLen} or 16 bytes`);
        if (nonceNcLen !== 12) {
            const nc = new Uint8Array(12);
            nc.set(nonce, counterRight ? 0 : 12 - nonce.length);
            nonce = nc;
            toClean.push(nonce);
        }
        const n32 = u32(nonce);
        runCipher(core, sigma, k32, n32, data, output, counter, rounds);
        clean(...toClean);
        return output;
    };
}

function rotl(a, b) {
    return a << b | a >>> 32 - b;
}

function chachaCore(s, k, n, out, cnt, rounds = 20) {
    const y00 = s[0], y01 = s[1], y02 = s[2], y03 = s[3], y04 = k[0], y05 = k[1], y06 = k[2], y07 = k[3], y08 = k[4], y09 = k[5], y10 = k[6], y11 = k[7], y12 = cnt, y13 = n[0], y14 = n[1], y15 = n[2];
    let x00 = y00, x01 = y01, x02 = y02, x03 = y03, x04 = y04, x05 = y05, x06 = y06, x07 = y07, x08 = y08, x09 = y09, x10 = y10, x11 = y11, x12 = y12, x13 = y13, x14 = y14, x15 = y15;
    for (let r = 0; r < rounds; r += 2) {
        x00 = x00 + x04 | 0;
        x12 = rotl(x12 ^ x00, 16);
        x08 = x08 + x12 | 0;
        x04 = rotl(x04 ^ x08, 12);
        x00 = x00 + x04 | 0;
        x12 = rotl(x12 ^ x00, 8);
        x08 = x08 + x12 | 0;
        x04 = rotl(x04 ^ x08, 7);
        x01 = x01 + x05 | 0;
        x13 = rotl(x13 ^ x01, 16);
        x09 = x09 + x13 | 0;
        x05 = rotl(x05 ^ x09, 12);
        x01 = x01 + x05 | 0;
        x13 = rotl(x13 ^ x01, 8);
        x09 = x09 + x13 | 0;
        x05 = rotl(x05 ^ x09, 7);
        x02 = x02 + x06 | 0;
        x14 = rotl(x14 ^ x02, 16);
        x10 = x10 + x14 | 0;
        x06 = rotl(x06 ^ x10, 12);
        x02 = x02 + x06 | 0;
        x14 = rotl(x14 ^ x02, 8);
        x10 = x10 + x14 | 0;
        x06 = rotl(x06 ^ x10, 7);
        x03 = x03 + x07 | 0;
        x15 = rotl(x15 ^ x03, 16);
        x11 = x11 + x15 | 0;
        x07 = rotl(x07 ^ x11, 12);
        x03 = x03 + x07 | 0;
        x15 = rotl(x15 ^ x03, 8);
        x11 = x11 + x15 | 0;
        x07 = rotl(x07 ^ x11, 7);
        x00 = x00 + x05 | 0;
        x15 = rotl(x15 ^ x00, 16);
        x10 = x10 + x15 | 0;
        x05 = rotl(x05 ^ x10, 12);
        x00 = x00 + x05 | 0;
        x15 = rotl(x15 ^ x00, 8);
        x10 = x10 + x15 | 0;
        x05 = rotl(x05 ^ x10, 7);
        x01 = x01 + x06 | 0;
        x12 = rotl(x12 ^ x01, 16);
        x11 = x11 + x12 | 0;
        x06 = rotl(x06 ^ x11, 12);
        x01 = x01 + x06 | 0;
        x12 = rotl(x12 ^ x01, 8);
        x11 = x11 + x12 | 0;
        x06 = rotl(x06 ^ x11, 7);
        x02 = x02 + x07 | 0;
        x13 = rotl(x13 ^ x02, 16);
        x08 = x08 + x13 | 0;
        x07 = rotl(x07 ^ x08, 12);
        x02 = x02 + x07 | 0;
        x13 = rotl(x13 ^ x02, 8);
        x08 = x08 + x13 | 0;
        x07 = rotl(x07 ^ x08, 7);
        x03 = x03 + x04 | 0;
        x14 = rotl(x14 ^ x03, 16);
        x09 = x09 + x14 | 0;
        x04 = rotl(x04 ^ x09, 12);
        x03 = x03 + x04 | 0;
        x14 = rotl(x14 ^ x03, 8);
        x09 = x09 + x14 | 0;
        x04 = rotl(x04 ^ x09, 7);
    }
    let oi = 0;
    out[oi++] = y00 + x00 | 0;
    out[oi++] = y01 + x01 | 0;
    out[oi++] = y02 + x02 | 0;
    out[oi++] = y03 + x03 | 0;
    out[oi++] = y04 + x04 | 0;
    out[oi++] = y05 + x05 | 0;
    out[oi++] = y06 + x06 | 0;
    out[oi++] = y07 + x07 | 0;
    out[oi++] = y08 + x08 | 0;
    out[oi++] = y09 + x09 | 0;
    out[oi++] = y10 + x10 | 0;
    out[oi++] = y11 + x11 | 0;
    out[oi++] = y12 + x12 | 0;
    out[oi++] = y13 + x13 | 0;
    out[oi++] = y14 + x14 | 0;
    out[oi++] = y15 + x15 | 0;
}
function hchacha(s, k, i, out) {
    let x00 = s[0], x01 = s[1], x02 = s[2], x03 = s[3], x04 = k[0], x05 = k[1], x06 = k[2], x07 = k[3], x08 = k[4], x09 = k[5], x10 = k[6], x11 = k[7], x12 = i[0], x13 = i[1], x14 = i[2], x15 = i[3];
    for (let r = 0; r < 20; r += 2) {
        x00 = x00 + x04 | 0;
        x12 = rotl(x12 ^ x00, 16);
        x08 = x08 + x12 | 0;
        x04 = rotl(x04 ^ x08, 12);
        x00 = x00 + x04 | 0;
        x12 = rotl(x12 ^ x00, 8);
        x08 = x08 + x12 | 0;
        x04 = rotl(x04 ^ x08, 7);
        x01 = x01 + x05 | 0;
        x13 = rotl(x13 ^ x01, 16);
        x09 = x09 + x13 | 0;
        x05 = rotl(x05 ^ x09, 12);
        x01 = x01 + x05 | 0;
        x13 = rotl(x13 ^ x01, 8);
        x09 = x09 + x13 | 0;
        x05 = rotl(x05 ^ x09, 7);
        x02 = x02 + x06 | 0;
        x14 = rotl(x14 ^ x02, 16);
        x10 = x10 + x14 | 0;
        x06 = rotl(x06 ^ x10, 12);
        x02 = x02 + x06 | 0;
        x14 = rotl(x14 ^ x02, 8);
        x10 = x10 + x14 | 0;
        x06 = rotl(x06 ^ x10, 7);
        x03 = x03 + x07 | 0;
        x15 = rotl(x15 ^ x03, 16);
        x11 = x11 + x15 | 0;
        x07 = rotl(x07 ^ x11, 12);
        x03 = x03 + x07 | 0;
        x15 = rotl(x15 ^ x03, 8);
        x11 = x11 + x15 | 0;
        x07 = rotl(x07 ^ x11, 7);
        x00 = x00 + x05 | 0;
        x15 = rotl(x15 ^ x00, 16);
        x10 = x10 + x15 | 0;
        x05 = rotl(x05 ^ x10, 12);
        x00 = x00 + x05 | 0;
        x15 = rotl(x15 ^ x00, 8);
        x10 = x10 + x15 | 0;
        x05 = rotl(x05 ^ x10, 7);
        x01 = x01 + x06 | 0;
        x12 = rotl(x12 ^ x01, 16);
        x11 = x11 + x12 | 0;
        x06 = rotl(x06 ^ x11, 12);
        x01 = x01 + x06 | 0;
        x12 = rotl(x12 ^ x01, 8);
        x11 = x11 + x12 | 0;
        x06 = rotl(x06 ^ x11, 7);
        x02 = x02 + x07 | 0;
        x13 = rotl(x13 ^ x02, 16);
        x08 = x08 + x13 | 0;
        x07 = rotl(x07 ^ x08, 12);
        x02 = x02 + x07 | 0;
        x13 = rotl(x13 ^ x02, 8);
        x08 = x08 + x13 | 0;
        x07 = rotl(x07 ^ x08, 7);
        x03 = x03 + x04 | 0;
        x14 = rotl(x14 ^ x03, 16);
        x09 = x09 + x14 | 0;
        x04 = rotl(x04 ^ x09, 12);
        x03 = x03 + x04 | 0;
        x14 = rotl(x14 ^ x03, 8);
        x09 = x09 + x14 | 0;
        x04 = rotl(x04 ^ x09, 7);
    }
    let oi = 0;
    out[oi++] = x00;
    out[oi++] = x01;
    out[oi++] = x02;
    out[oi++] = x03;
    out[oi++] = x12;
    out[oi++] = x13;
    out[oi++] = x14;
    out[oi++] = x15;
}

var xchacha20 = /* @__PURE__ */ createCipher(chachaCore, {
    counterRight: false,
    counterLength: 8,
    extendNonceFn: hchacha,
    allowShortKeys: false
});

function randomBytes(bytesLength = 32) {
    const cr = typeof globalThis === "object" ? globalThis.crypto : null;
    if (typeof cr?.getRandomValues !== "function")
        throw new Error("crypto.getRandomValues must be defined");
    return cr.getRandomValues(new Uint8Array(bytesLength));
}

var xchacha20poly1305 = /* @__PURE__ */ wrapCipher({ blockSize: 64, nonceLength: 24, tagLength: 16 }, _poly1305_aead(xchacha20));

var hasHexBuiltin = /* @__PURE__ */ (() => (
    // @ts-ignore
    typeof Uint8Array.from([]).toHex === "function" && typeof Uint8Array.fromHex === "function"
))();

var asciis = { _0: 48, _9: 57, A: 65, F: 70, a: 97, f: 102 };
function asciiToBase16(ch) {
    if (ch >= asciis._0 && ch <= asciis._9)
        return ch - asciis._0;
    if (ch >= asciis.A && ch <= asciis.F)
        return ch - (asciis.A - 10);
    if (ch >= asciis.a && ch <= asciis.f)
        return ch - (asciis.a - 10);
    return;
}

function hexToBytes(hex: string): Uint8Array {
    if (typeof hex !== "string")
        throw new Error("hex string expected, got " + typeof hex);
    if (hasHexBuiltin)
        return (Uint8Array as any).fromHex(hex);
    const hl = hex.length;
    const al = hl / 2;
    if (hl % 2)
        throw new Error("hex string expected, got unpadded hex of length " + hl);
    const array = new Uint8Array(al);
    for (let ai = 0, hi = 0; ai < al; ai++, hi += 2) {
        const n1 = asciiToBase16(hex.charCodeAt(hi));
        const n2 = asciiToBase16(hex.charCodeAt(hi + 1));
        if (n1 === void 0 || n2 === void 0) {
            const char = hex[hi] + hex[hi + 1];
            throw new Error('hex string expected, got non-hex character "' + char + '" at index ' + hi);
        }
        array[ai] = n1 * 16 + n2;
    }
    return array;
}

// The code above was extracted from noble-ciphers (https://github.com/paulmillr/noble-ciphers) and is licensed under:
// The MIT License (MIT)

// Copyright (c) 2022 Paul Miller (https://paulmillr.com)
// Copyright (c) 2016 Thomas Pornin <pornin@bolet.org>

// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the “Software”), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:

// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.

// THE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

// const key = hexToBytes("4b7f89bac90a1086fef73f5da2cbe93b2fae9dfbf7678ae1f3e75fd118ddf999");

import { settings } from "./settings";

const key = hexToBytes(settings.use(["key"]).key);

type pkg = { n: [], d: []; };

export async function encrypt(_, msg: string): Promise<string> {
    try {
        const nonce: Uint8Array = randomBytes(24);
        const chacha = xchacha20poly1305(key, nonce);
        const data = new TextEncoder().encode(msg);
        const encrypted: Uint8Array = chacha.encrypt(data);

        const pkg = "«SECURE»" + Buffer.from(JSON.stringify({
            n: Array.from(nonce),
            d: Array.from(encrypted)
        })).toString("base64");

        return pkg.length > 1992 ? "«Message too long»" : pkg;
    }
    catch {
        return "«Encryption Error»";
    }
}

export async function decrypt(_, msg: string): Promise<string> {
    try {
        const base64 = msg.slice(8, msg.length);
        const pkg: pkg = JSON.parse(Buffer.from(base64, "base64").toString());
        const nonce: Uint8Array = new Uint8Array(pkg.n);
        const data: Uint8Array = new Uint8Array(pkg.d);
        const chacha = xchacha20poly1305(key, nonce);
        const decrypted = chacha.decrypt(data);

        return "«🔒»    " + new TextDecoder().decode(decrypted);
    }
    catch {
        return "«Message has differing key»";
    }
}
